package com.github.kaeptmblaubaer1000.smalisignaturepatchgenerator.updateParser

import com.github.kaeptmblaubaer1000.smalisignaturepatchgenerator.patchdefparser.NullablePatchDef
import com.github.kaeptmblaubaer1000.smalisignaturepatchgenerator.patchdefparser.PatchDef
import com.github.kaeptmblaubaer1000.smalisignaturepatchgenerator.patchdefparser.PatchDefBaseListener
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.asTypeName
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardOpenOption
import kotlin.reflect.KProperty1
import kotlin.reflect.full.memberProperties
import kotlin.reflect.jvm.jvmErasure


private const val BEGIN_COMMENT = "/** BEGIN OF CODE GENERATED BY updateParser FROM PatchDef **/"
private const val END_COMMENT = "/** END OF CODE GENERATED BY updateParser FROM PatchDef **/"

fun main(vararg args: String) {
    val kClass = PatchDef::class

    val props = kClass.memberProperties.filter { it.returnType.jvmErasure == String::class }.map(KProperty1<PatchDef, *>::name)

    run {
        val grammarPath = Paths.get("..", "parsergrammar", "src", "main", "antlr", "com", "github", "kaeptmblaubaer1000", "smalisignaturepatchgenerator", "patchdefparser", "PatchDef.g4")
        val content = Files.readAllBytes(grammarPath).toString(Charsets.UTF_8)
        // Checking whether end comes before begin would make the code more complicated.
        val begin = content.take(content.indexOf(BEGIN_COMMENT) - 1)
        val end = content.drop(content.lastIndexOf(END_COMMENT) + END_COMMENT.length + 1)

        val generatedAntlr = """$begin
/** BEGIN OF CODE GENERATED BY updateParser FROM PatchDef **/
// This part of the file is generated. DO NOT CHANGE!
assignment : (${props.map { "${it}Assignment" }.reduce { acc, s -> "$acc | $s" }}) ;

${props.map { "${it}Assignment : '$it' WHITESPACE* '=' WHITESPACE* StringLiteral ;" }.reduce { acc, s -> "$acc\n$s" }}
/** END OF CODE GENERATED BY updateParser FROM PatchDef **/
$end"""
        Files.write(grammarPath, generatedAntlr.toByteArray(Charsets.UTF_8), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)

        null
    }


    val nullablePatchDefSpec = com.squareup.kotlinpoet.TypeSpec.classBuilder(ClassName("com.github.kaeptmblaubaer1000.smalisignaturepatchgenerator.patchdefparser", "NullablePatchDef"))
            .addProperties(props.map {
                PropertySpec
                        .varBuilder(it, String::class.asTypeName().asNullable())
                        .initializer(it)
                        .build()
            })
            .primaryConstructor(FunSpec
                    .constructorBuilder()
                    .addParameters(props.map {
                        ParameterSpec
                                .builder(it, String::class.asTypeName().asNullable())
                                .defaultValue("null")
                                .build()
                    })
                    .build())
            .addFunction(FunSpec
                    .builder("toNonNullable")
                    .returns(PatchDef::class.asTypeName().asNullable())
                    // The space at the beginning is no mistake, it prevents expression body which breaks the following returns
                    .addCode("%<    return PatchDef(\n%>%>%>")
                    .apply {
                        props.subList(0, props.size - 1).map { addCode("%1N = %1N ?: return null,\n", it) }
                        val lastProp = props.lastOrNull()
                        if (lastProp != null) {
                            addCode("%1N = %1N ?: return null\n", lastProp)
                        }
                    }
                    .addCode("%<%<)\n")
                    .build())
            .addModifiers(KModifier.DATA)
            .build()
    val patchDefListenerBuilder = com.squareup.kotlinpoet.TypeSpec
            .classBuilder(ClassName("com.github.kaeptmblaubaer1000.smalisignaturepatchgenerator.patchdefparser", "PatchDefListenerImpl"))
            .superclass(PatchDefBaseListener::class)
            .addProperty(PropertySpec
                    .builder("patchDef", NullablePatchDef::class)
                    .addModifiers(KModifier.PRIVATE)
                    .initializer("patchDef")
                    .build())
            .primaryConstructor(FunSpec
                    .constructorBuilder()
                    .addParameter("patchDef", NullablePatchDef::class)
                    .build())

    for (prop in props) {
        patchDefListenerBuilder.addFunction(FunSpec
                .builder("exit${prop.capitalize()}Assignment")
                .addModifiers(KModifier.OVERRIDE)
                .addParameter("ctx", ClassName("com.github.kaeptmblaubaer1000.smalisignaturepatchgenerator.patchdefparser", "PatchDefParser", "${prop.capitalize()}AssignmentContext"))
                .addCode("patchDef.%1N = unquoteUnescapeJavaString(ctx.StringLiteral().text)\n", prop)
                .build())
    }

    val fileSpec = FileSpec
            .builder("com.github.kaeptmblaubaer1000.smalisignaturepatchgenerator.patchdefparser", "Generated")
            .addComment("This file is generated by updateParser. DO NOT CHANGE! MAKE CHANGES THERE!")
            .addType(nullablePatchDefSpec)
            .addType(patchDefListenerBuilder.build())
            .build()

    fileSpec.writeTo(Paths.get("..", "parser", "src", "main", "java"))

}